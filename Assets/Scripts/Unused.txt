//public class AlgorithmOld
//{
//    private const float MIN_PORTION_SCALE = 0.5f;
//    private const float MAX_PORTION_SCALE = 2.0f;

//    private const int NUM_MEALS = 4;
//    private static Random rng = new();

//    private static List<Portion> allPortions = new();
//    private static List<Meal> mealPopulation = new();

//    // Soft constraints
//    private static List<Constraint> Constraints = new()
//    {
//    // Hard constraints
//    { new(Proximate.Trans, ConstraintType.HardLessThan, 50, 5) },
//    { new(Proximate.Sugars, ConstraintType.HardLessThan, 30, 36) },
//    { new(Proximate.Saturates, ConstraintType.HardLessThan, 30, 30) },

//    // Soft constraints
//    { new(Proximate.Energy, ConstraintType.Converge, 20, 3000) },

//    { new(Proximate.Fat, ConstraintType.Converge, 10, 250) },
//    { new(Proximate.Protein, ConstraintType.Converge, 10, 113) },
//    { new(Proximate.Carbs, ConstraintType.Converge, 10, 75) },
//    };


//    public static void Main()
//    {
//        Console.WriteLine($"Highest possible fitness: {Constraints.Select(x => x.Weight).Sum()}");

//        // Create portion population

//        // Randomly generate a smaller, local population, with no mutations
//        for (int i = 0; i < 10; i++)
//        {
//            int index = rng.Next(allPortions.Count);
//            Meal meal = new();
//            meal.Portions.Add(new(allPortions[index]));
//            mealPopulation.Add(meal);
//        }

//        int G = -1;

//        // Main loop of the algorithm
//        while (true)
//        {
//            G++;

//            Console.WriteLine($"GENERATION {G}");
//            CalculateFitnesses();

//            if (G > 0)
//            {
//                List<Meal> children = Run();
//                Console.WriteLine();

//                // Add to the population so they can be sorted with the rest
//                int addedWinners = 0;
//                for (int i = 0; i < children.Count; i++)
//                {
//                    if (children[i].Mutations == -1)
//                        continue;

//                    CalculateFitness(children[i]);
//                    mealPopulation.Add(children[i]);
//                    addedWinners++;
//                }

//                mealPopulation.Sort(Meal.Compare);

//                // "Kill off" the weakest entries
//                for (int j = 0; j < addedWinners; j++)
//                {
//                    mealPopulation.RemoveAt(0);
//                }
//            }

//            Display();
//            Console.WriteLine(mealPopulation.Count);

//            Console.WriteLine();
//            Console.WriteLine();
//            Console.WriteLine();
//            Console.WriteLine();

//            if (G % 100 == 0)
//                Console.ReadKey();
//        }
//    }


//    /// <summary>
//    /// Runs the body of the algorithm.
//    /// </summary>
//    /// <returns>The winning meals, to be added to the population.</returns>
//    private static List<Meal> Run()
//    {
//        // Tournament selection
//        // Children are initially copies of their parents before mutation, crossover, etc.
//        Meal child1 = new(Duel());
//        Meal child2 = new(Duel());

//        // Crossover (if applicable)
//        int portions1 = child1.Portions.Count;
//        int portions2 = child2.Portions.Count;
//        if (portions1 > 1 && portions2 > 1)
//        {
//            int index1 = rng.Next(portions1);
//            int index2 = rng.Next(portions2);

//            Portion portion1 = new(child1.Portions[index1]);
//            Portion portion2 = new(child2.Portions[index2]);

//            child1.Portions[index1] = portion2;
//            child2.Portions[index2] = portion1;
//        }

//        // Mutation
//        Mutate(child1); Mutate(child2);

//        return new List<Meal>() { child1, child2 };
//    }


//    private static void Mutate(Meal meal)
//    {
//        bool removePortion = CoinFlip();
//        bool addPortion = !removePortion;

//        // Remove random portion
//        if (removePortion)
//        {
//            if (meal.Portions.Count < 2)
//            {
//                meal.Mutations = -1; // Indicate the mutation failed and this meal is to be discarded.
//                return;
//            }
//            int randIndex = rng.Next(meal.Portions.Count);
//            meal.Portions.RemoveAt(randIndex);
//        }

//        // Add random portion
//        if (addPortion)
//        {
//            Portion newPortion = new(allPortions[rng.Next(allPortions.Count)]);
//            meal.Portions.Add(newPortion);
//        }

//        meal.Mutations++;
//    }


//    private static bool CoinFlip()
//    {
//        return rng.Next(2) == 1;
//    }


//    private static Meal Duel()
//    {
//        int popIndexA = rng.Next(mealPopulation.Count);
//        int popIndexB = rng.Next(mealPopulation.Count);

//        if (popIndexB == popIndexA)
//        {
//            if (popIndexA != mealPopulation.Count - 1)
//                popIndexB = Math.Min(popIndexB + 1, mealPopulation.Count - 1);
//            else
//                popIndexB = 0;
//        }

//        return Tournament(MaximiseFitness, new() { mealPopulation[popIndexA], mealPopulation[popIndexB] });
//    }


//    private static Winner MaximiseFitness(Meal L, Meal R)
//    {
//        Winner winner = Winner.None;

//        Console.WriteLine("Tournament: Fitness");
//        L.Print();
//        Console.WriteLine();
//        R.Print();
//        Console.WriteLine();

//        if (L.LastFitness >= R.LastFitness)
//        {
//            winner |= Winner.Left;
//        }
//        if (R.LastFitness >= L.LastFitness)
//        {
//            winner |= Winner.Right;
//        }

//        Console.WriteLine($"Left : {L.LastFitness}, Right : {R.LastFitness}, Winner : {winner}\n");
//        return winner;
//    }


//    /// <summary>
//    /// A generic tournament where 2 or more population members fight "to the death". If they are
//    /// equal, a coin flip decides the winner.
//    /// </summary>
//    /// <param name="comparison">A generic function which returns:
//    /// 1 if arg 1 beats arg 2. -1 if arg 2 beats arg 1. 0 if arg 1 and arg 2 are equals.</param>
//    /// <param name="competitors">A list of potential competitors.</param>
//    /// <returns>The winning meal.</returns>
//    private static Meal Tournament(Func<Meal, Meal, Winner> comparison, List<Meal> competitors)
//    {
//        int left = 0;
//        int right = 1;

//        // 1 competitor => they have already won; 0 competitors => No tournament
//        while (competitors.Count > 1)
//        {
//            Winner winner = comparison(competitors[left], competitors[right]);

//            if (winner == Winner.Left)
//            {
//                competitors.RemoveAt(right);
//            }
//            else if (winner == Winner.Right)
//            {
//                competitors.RemoveAt(left);
//            }
//            else
//            {
//                // Randomly strike one of the two competitors down by the equivalent of an
//                // "act of God" - there are no ties.

//                float lightningBolt = (float)rng.NextDouble();
//                if (lightningBolt >= 0.5f)
//                    competitors.RemoveAt(right);
//                else
//                    competitors.RemoveAt(left);
//            }
//        }

//        if (competitors.Count == 0)
//        {
//            Console.WriteLine("Empty tournament led to no winners.");
//            return null;
//        }

//        //competitors[0].Print();
//        //Console.WriteLine();

//        return competitors[0];
//    }


//    /// <summary>
//    /// Calls CalculateFitness on every meal in the population.
//    /// </summary>
//    private static void CalculateFitnesses()
//    {
//        for (int i = 0; i < mealPopulation.Count; i++)
//        {
//            mealPopulation[i].TotalFitness(Constraints, NUM_MEALS);
//        }
//    }


//    /// <summary>
//    /// Calculates the fitness of a meal in the population.
//    /// Cached under the LastFitness property.
//    /// </summary>
//    private static void CalculateFitness(Meal meal)
//    {
//        meal.TotalFitness(Constraints, NUM_MEALS);
//    }


//    private static List<Meal> SortFitnesses()
//    {
//        List<Meal> meals = new();

//        for (int i = 0; i < mealPopulation.Count; i++)
//        {
//            if (meals.Count == 0)
//                meals.Add(mealPopulation[i]);
//            else
//            {
//                for (int j = 0; j < meals.Count; j++)
//                {
//                    if (mealPopulation[i].LastFitness > meals[j].LastFitness)
//                    {
//                        if (j == meals.Count - 1)
//                            meals.Add(mealPopulation[i]);
//                        continue;
//                    }
//                    meals.Insert(j, mealPopulation[i]);
//                    break;
//                }
//            }
//        }

//        return meals;
//    }


//    private static void Display()
//    {
//        float totFitness = 0f;
//        foreach (Meal m in mealPopulation)
//        {
//            m.Print();
//            Console.WriteLine($"Fitness: {m.LastFitness}\n");
//            totFitness += m.LastFitness;
//        }
//        Console.WriteLine($"Avg. Fitness: {totFitness / mealPopulation.Count}");
//    }
//}



        /// <summary>
        /// (Unused)
        /// Allows the user to input the nutrients in command-line.
        /// </summary>
        private static float[]? GetNutrientInput()
        {
            float[] floats = new float[Nutrient.Count];
            for (int i = 0; i < Nutrient.Count; i++)
            {
                Console.Write($"[float] Enter the value for {Nutrient.Values[i]}\n> ");
                string? line = Console.ReadLine();

                if (line != null && float.TryParse(line, out floats[i]))
                {
                    if (floats[i] < 0)
                        return null;

                    continue;
                }

                // Restart the iteration
                Console.WriteLine("Invalid input. Please try again.");
                i--;
            }

            return floats;
        }


        
    //public static void PlotGraph(Coordinates[] graph, string name)
    //{
    //    Plot plot = MakeLinearPlot(graph.Length, Preferences.MAX_FITNESS, graph);
    //    plot.SavePng(FileTools.GetProjectDirectory() + $"{name}.png", 1920, 1080);
    //}


    //private static Plot MakeLinearPlot(int xMax, int yMax, Coordinates[] graph)
    //{
    //    Plot plot = InitPlot(graph);

    //    plot.Axes.SetLimitsX(0, xMax);
    //    plot.Axes.SetLimitsY(0, yMax);

    //    return plot;
    //}


    ///// <summary>
    ///// Adjust the "ticks" (axis jumps) so they match the log/log graph data.
    ///// Reference: https://scottplot.net/cookbook/5.0/CustomizingTicks/LogScaleTicks/ (ScottPlot docs)
    ///// </summary>
    ///// <param name="plot">The plot to apply the custom ticks to.</param>
    //private static Plot MakeLogPlot(int xMax, int yMax, Coordinates[] graph)
    //{
    //    Plot plot = InitPlot(graph);

    //    // Log tick generator
    //    ScottPlot.TickGenerators.LogMinorTickGenerator minorTickGen = new();

    //    // Numeric tick generator using the log tick generator
    //    ScottPlot.TickGenerators.NumericAutomatic tickGen = new()
    //    {
    //        MinorTickGenerator = minorTickGen,

    //        // Tick formatter, sets label text for each tick
    //        LabelFormatter = (double y) =>
    //        {
    //            return $"{Math.Pow(10, y):N0}";
    //        },

    //        // tell our major tick generator to only show major ticks that are whole integers
    //        IntegerTicksOnly = true
    //    };

    //    // Apply tick generator to axes
    //    plot.Axes.Left.TickGenerator = tickGen;
    //    plot.Axes.Bottom.TickGenerator = tickGen;

    //    // Show grid lines for minor ticks
    //    var grid = plot.GetDefaultGrid();
    //    grid.MajorLineStyle.Color = Colors.Black.WithOpacity(.15);
    //    grid.MinorLineStyle.Color = Colors.Black.WithOpacity(.05);
    //    grid.MinorLineStyle.Width = 1;

    //    // Set axis limits
    //    plot.Axes.SetLimitsX(0, Math.Log10(xMax));
    //    plot.Axes.SetLimitsY(0, Math.Log10(yMax));

    //    return plot;
    //}


    #if !UNITY_64
public static class FileTools
{
    public static string GetProjectDirectory()
    {
         E.g. Project/bin/Debug/net8.0/
        string cwd = Environment.CurrentDirectory;

        
        DirectoryInfo compileTarget = Directory.GetParent(cwd)!; // E.g. Project/bin/Debug/
        DirectoryInfo bin = compileTarget.Parent!; // E.g. Project/bin/
        
         Now in Project folder
        return bin.Parent!.FullName + "\\";
    }
}
#endif


//using System;
//using System.Collections.Generic;
//using System.Collections.ObjectModel;


//using Random = System.Random;


//public class AlgPDGA : AlgGA
//{
//    // The index of sorting set the algorithm goes up to during a tiebreak.
//    // The higher it is, the more likely to resolve a tiebreak.
//    //
//    // [0, PopHierarchy.Length)
//    protected const int SELECTION_PRESSURE = 5;
//    public const int NUM_SORTING_SETS = 10;

//    private List<MNDSet> m_sets;
//    public ReadOnlyCollection<MNDSet> Sets;


//    public override void Init()
//    {
//        m_sets = new();
//        Sets = new(m_sets);

//        base.Init();
//    }


//    ///// <summary>
//    ///// Pareto-dominance tournament selection.
//    ///// </summary>
//    //protected override Day Selection(List<Day> candidates, bool selectBest = true)
//    //{
//    //    int indexA = Rand.Next(candidates.Count);
//    //    // Ensure B is different to A by adding an amount less than the list size, then %-ing it.
//    //    int indexB = (indexA + Rand.Next(1, candidates.Count - 1)) % candidates.Count;

//    //    // If one dominates the other, the selection is simple.
//    //    // Don't make use of PopHierarchy, because this method is sometimes called before PopHierarchy
//    //    // is updated with the new population.
//    //    switch (Day.Compare(candidates[indexA], candidates[indexB]))
//    //    {
//    //        case ParetoComparison.Dominates:
//    //            return selectBest ? candidates[indexA] : candidates[indexB];
//    //        case ParetoComparison.Dominated:
//    //            return selectBest ? candidates[indexB] : candidates[indexA];
//    //    }

//    //    // Otherwise, tiebreak by comparison set
//    //    return SelectionTiebreak(candidates[indexA], candidates[indexB]);
//    //}


//    /// <summary>
//    /// Adds a day (if possible) to one of the comparison sets.
//    /// If the day gets dominated by all other comparison set members, it will not get added to any.
//    /// </summary>
//    protected override void AddToPopulation(Day day)
//    {
//        base.AddToPopulation(day);

//        for (int i = 0; i < Sets.Count; i++)
//        {
//            MNDSet set = Sets[i];
//            switch (Pareto.UnstrictComparison(set.Compare(day)))
//            {
//                // If the first set it beats, it dominates it, then we need a new set for this Day.
//                case ParetoComparison.Dominates:
//                    MNDSet newSet = new();
//                    newSet.Add(day);
//                    m_sets.Insert(i, newSet);
//                    return;

//                // MND => This day belongs in this set.
//                case ParetoComparison.MutuallyNonDominating:
//                    m_sets[i].Add(day);
//                    return;

//                // Continue until we find a set matching the above criteria
//                case ParetoComparison.Dominated:
//                default:
//                    continue;
//            }
//        }
//    }


//    /// <summary>
//    /// Will remove a day from the sort, if it is in a comparison set.
//    /// </summary>
//    protected override void RemoveFromPopulation(Day day)
//    {
//        base.RemoveFromPopulation(day);

//        for (int i = 0; i < Sets.Count; i++)
//        {
//            MNDSet set = Sets[i];
//            if (set.Days.Contains(day))
//            {
//                set.Remove(day);
//                // Remove resulting empty set
//                if (set.Days.Count == 0)
//                    m_sets.Remove(set);
//            }
//        }
//    }


//    protected override void Selection()
//    {
//        //List<Day> days = new(m_population.Days);
//        //Day a = PickRandomDay(days);
//        //days.Remove(a);
//        //Day b = PickRandomDay(days);
//        //days.Remove(b);

//        //int rankA = TryGetDayRank(a);
//        //int rankB = TryGetDayRank(b);

//        //if (selectBest)
//        //{
//        //    if (rankA < rankB) return a;
//        //    if (rankB < rankA) return b;
//        //}
//        //else
//        //{
//        //    if (rankA > rankB) return a;
//        //    if (rankB > rankA) return b;
//        //}

//        //// Otherwise, tiebreak by comparison set
//        //return Tiebreak(a, b, selectBest);
//    }


//    /// <summary>
//    /// First, tiebreak based on their total dominance over the population.
//    /// If a has a domination of n, and b has a domination of n + 1, b wins.
//    /// 
//    /// If it still hasn't been resolved, tiebreak based on fitness.
//    /// 
//    /// If it still hasn't, select randomly.
//    /// </summary>
//    private Day Tiebreak(Day a, Day b, bool selectBest)
//    {
//        List<Day> comparisonSet = new(m_population.DayFitnesses.Keys);
//        for (int i = 0; i < Sets.Count; i++)
//        {
//            comparisonSet.AddRange(Sets[i].Days);
//        }

//        comparisonSet.Remove(a);
//        comparisonSet.Remove(b);

//        int dominanceA = GetDominanceOverComparisonSet(a, comparisonSet);
//        int dominanceB = GetDominanceOverComparisonSet(b, comparisonSet);
//        if (selectBest)
//        {
//            if (dominanceA > dominanceB) return a;
//            if (dominanceB > dominanceA) return b;
//            if (m_population.GetFitness(a) < m_population.GetFitness(b)) return a;
//            if (m_population.GetFitness(b) < m_population.GetFitness(a)) return b;
//        }
//        else
//        {
//            if (dominanceA < dominanceB) return a;
//            if (dominanceB < dominanceA) return b;
//            if (m_population.GetFitness(a) > m_population.GetFitness(b)) return a;
//            if (m_population.GetFitness(b) > m_population.GetFitness(a)) return b;
//        }

//        if (Rand.Next(2) == 1)
//            return a;
//        return b;
//    }


//    /// <summary>
//    /// Calculates how dominant a day is over a mutually-non-dominating set.
//    /// </summary>
//    /// <returns>An integer, which starts at 0 and increments every time the day dominates,
//    /// and decrements every time it is dominated.</returns>
//    protected int GetDominanceOverComparisonSet(Day day, List<Day> set)
//    {
//        int dominance = 0;
//        for (int i = 0; i < set.Count; i++)
//        {
//            int rankDay = TryGetDayRank(day);
//            int rankOther = TryGetDayRank(set[i]);

//            if (rankDay < rankOther)
//                dominance++;
//            if (rankOther < rankDay)
//                dominance--;
//        }

//        return dominance;
//    }
//}



public float GetFitness()
    {
        // Calculate the overall fitness value based on the sum of the fitness of the individual
        // nutrient amounts. (E.g. protein leads to a fitness value, which is multiplied to the fat fitness,
        // etc... over all nutrients).

        float fitness = 0;

        for (int i = 0; i < Nutrient.Count; i++)
        {
            float amount = m_nutrientAmounts[i];
            fitness += m_algorithm.Constraints[i].GetFitness(amount);

            // Quick exit for infinity fitness
            if (fitness == float.PositiveInfinity)
            {
                //Logger.Log($"{Nutrient.Values[i]} : {Preferences.Instance.constraints[i].Type} {((HardConstraint)m_algorithm.Constraints[i]).min} {amount} {((HardConstraint)m_algorithm.Constraints[i]).max} gave finf");
                return fitness;
            }
        }

        if (Preferences.Instance.addFitnessForMass)
        {
            // Penalise portions with mass over the maximum (Food mass constraint)
            foreach (Portion p in portions)
            {
                fitness += MathF.Max(p.Mass - Preferences.Instance.maxPortionMass, 0);
            }
        }

        return fitness;
    }


//public enum ParetoComparison
//{
//    StrictlyDominates,
//    Dominates,
//    MutuallyNonDominating,
//    Dominated,
//    StrictlyDominated
//}


//public static class Pareto
//{
//    /// <summary>
//    /// Converts a regular pareto comparison to one which doesn't include strict domination.
//    /// </summary>
//    public static ParetoComparison UnstrictComparison(ParetoComparison p)
//    {
//        return p switch
//        {
//            ParetoComparison.StrictlyDominates or ParetoComparison.Dominates => ParetoComparison.Dominates,
//            ParetoComparison.StrictlyDominated or ParetoComparison.Dominated => ParetoComparison.Dominated,
//            _ => ParetoComparison.MutuallyNonDominating,
//        };
//    }


//    public static bool DominatesOrMND(ParetoComparison p)
//    {
//        return p switch
//        {
//            ParetoComparison.StrictlyDominates or ParetoComparison.Dominates or ParetoComparison.MutuallyNonDominating => true,
//            _ => false
//        };
//    }


//    public static bool DominatedOrMND(ParetoComparison p)
//    {
//        return p switch
//        {
//            ParetoComparison.StrictlyDominated or ParetoComparison.Dominated or ParetoComparison.MutuallyNonDominating => true,
//            _ => false
//        };
//    }


//    public static bool IsNonDominated(Day day, List<Day> population)
//    {
//        foreach (Day other in population)
//        {
//            if (day == other) continue;

//            switch (UnstrictComparison(day.CompareTo(other)))
//            {
//                // Only case where this day is NOT non-dominated.
//                case ParetoComparison.Dominated:
//                    return false;
//            }
//        }

//        return true;
//    }
//}